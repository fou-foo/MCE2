paste0('BGR.Canny', 1:m) ,
paste0('PC1.', 1:m) ,
paste0('PC2.', 1:m) ,
paste0('PC3.', 1:m) ,
paste0('PC1.Espacial', 1:m) ,
paste0('PC2.Espacial', 1:m) ,
paste0('PC3.Espacial', 1:m) )
paste0('RGB.Laplaciano', 1:m
)
c(paste0('RGB.Laplaciano', 1:m),
paste0('RGB.Sobelx', 1:m) ,
paste0('RGB.Sobely', 1:m) ,
paste0('RGB.Canny', 1:m) ,
paste0('R', 1:m) ,
paste0('G', 1:m) ,
paste0('B', 1:m) ,
paste0('R.Espacial', 1:m) ,
paste0('G.Espacial', 1:m) ,
paste0('B.Espacial', 1:m) ,
paste0('HSV.Laplaciano', 1:m),
paste0('HSV.Sobelx', 1:m) ,
paste0('HSV.Sobely', 1:m) ,
paste0('HSV.Canny', 1:m) ,
paste0('H', 1:m) ,
paste0('S', 1:m) ,
paste0('V', 1:m),
paste0('H.Espacial', 1:m) ,
paste0('S.Espacial', 1:m),
paste0('V.Espacial', 1:m),
paste0('Eigen', 1:3) ,
paste0('BGR.Laplaciano', 1:m),
paste0('BGR.Sobelx', 1:m) ,
paste0('BGR.Sobely', 1:m) ,
paste0('BGR.Canny', 1:m) ,
paste0('PC1.', 1:m) ,
paste0('PC2.', 1:m) ,
paste0('PC3.', 1:m) ,
paste0('PC1.Espacial', 1:m) ,
paste0('PC2.Espacial', 1:m) ,
paste0('PC3.Espacial', 1:m) )
c(paste0('RGB.Laplaciano', 1:m),
paste0('RGB.Sobelx', 1:m) ,
paste0('RGB.Sobely', 1:m) ,
paste0('RGB.Canny', 1:m) ,
paste0('R', 1:m) ,
paste0('G', 1:m) ,
paste0('B', 1:m) ,
paste0('R.Espacial', 1:m) ,
paste0('G.Espacial', 1:m) ,
paste0('B.Espacial', 1:m) ,
paste0('HSV.Laplaciano', 1:m),
paste0('HSV.Sobelx', 1:m) ,
paste0('HSV.Sobely', 1:m) ,
paste0('HSV.Canny', 1:m) ,
paste0('H', 1:m) ,
paste0('S', 1:m) ,
paste0('V', 1:m),
paste0('H.Espacial', 1:m) ,
paste0('S.Espacial', 1:m),
paste0('V.Espacial', 1:m),
paste0('Eigen', 1:3) ,
paste0('BGR.Laplaciano', 1:m),
paste0('BGR.Sobelx', 1:m) ,
paste0('BGR.Sobely', 1:m) ,
paste0('BGR.Canny', 1:m) ,
paste0('PC1.', 1:m) ,
paste0('PC2.', 1:m) ,
paste0('PC3.', 1:m) ,
paste0('PC1.Espacial', 1:m) ,
paste0('PC2.Espacial', 1:m) ,
paste0('PC3.Espacial', 1:m) )
m <- 5
c(paste0('RGB.Laplaciano', 1:m),
paste0('RGB.Sobelx', 1:m) ,
paste0('RGB.Sobely', 1:m) ,
paste0('RGB.Canny', 1:m) ,
paste0('R', 1:m) ,
paste0('G', 1:m) ,
paste0('B', 1:m) ,
paste0('R.Espacial', 1:m) ,
paste0('G.Espacial', 1:m) ,
paste0('B.Espacial', 1:m) ,
paste0('HSV.Laplaciano', 1:m),
paste0('HSV.Sobelx', 1:m) ,
paste0('HSV.Sobely', 1:m) ,
paste0('HSV.Canny', 1:m) ,
paste0('H', 1:m) ,
paste0('S', 1:m) ,
paste0('V', 1:m),
paste0('H.Espacial', 1:m) ,
paste0('S.Espacial', 1:m),
paste0('V.Espacial', 1:m),
paste0('Eigen', 1:3) ,
paste0('BGR.Laplaciano', 1:m),
paste0('BGR.Sobelx', 1:m) ,
paste0('BGR.Sobely', 1:m) ,
paste0('BGR.Canny', 1:m) ,
paste0('PC1.', 1:m) ,
paste0('PC2.', 1:m) ,
paste0('PC3.', 1:m) ,
paste0('PC1.Espacial', 1:m) ,
paste0('PC2.Espacial', 1:m) ,
paste0('PC3.Espacial', 1:m) )
m <- 3
c(paste0('RGB.Laplaciano', 1:m),
paste0('RGB.Sobelx', 1:m) ,
paste0('RGB.Sobely', 1:m) ,
paste0('RGB.Canny', 1:m) ,
paste0('R', 1:m) ,
paste0('G', 1:m) ,
paste0('B', 1:m) ,
paste0('R.Espacial', 1:m) ,
paste0('G.Espacial', 1:m) ,
paste0('B.Espacial', 1:m) ,
paste0('HSV.Laplaciano', 1:m),
paste0('HSV.Sobelx', 1:m) ,
paste0('HSV.Sobely', 1:m) ,
paste0('HSV.Canny', 1:m) ,
paste0('H', 1:m) ,
paste0('S', 1:m) ,
paste0('V', 1:m),
paste0('H.Espacial', 1:m) ,
paste0('S.Espacial', 1:m),
paste0('V.Espacial', 1:m),
paste0('Eigen', 1:3) ,
paste0('BGR.Laplaciano', 1:m),
paste0('BGR.Sobelx', 1:m) ,
paste0('BGR.Sobely', 1:m) ,
paste0('BGR.Canny', 1:m) ,
paste0('PC1.', 1:m) ,
paste0('PC2.', 1:m) ,
paste0('PC3.', 1:m) ,
paste0('PC1.Espacial', 1:m) ,
paste0('PC2.Espacial', 1:m) ,
paste0('PC3.Espacial', 1:m) )
m <- 4
c(paste0('RGB.Laplaciano', 1:m),
paste0('RGB.Sobelx', 1:m) ,
paste0('RGB.Sobely', 1:m) ,
paste0('RGB.Canny', 1:m) ,
paste0('R', 1:m) ,
paste0('G', 1:m) ,
paste0('B', 1:m) ,
paste0('R.Espacial', 1:m) ,
paste0('G.Espacial', 1:m) ,
paste0('B.Espacial', 1:m) ,
paste0('HSV.Laplaciano', 1:m),
paste0('HSV.Sobelx', 1:m) ,
paste0('HSV.Sobely', 1:m) ,
paste0('HSV.Canny', 1:m) ,
paste0('H', 1:m) ,
paste0('S', 1:m) ,
paste0('V', 1:m),
paste0('H.Espacial', 1:m) ,
paste0('S.Espacial', 1:m),
paste0('V.Espacial', 1:m),
paste0('Eigen', 1:3) ,
paste0('BGR.Laplaciano', 1:m),
paste0('BGR.Sobelx', 1:m) ,
paste0('BGR.Sobely', 1:m) ,
paste0('BGR.Canny', 1:m) ,
paste0('PC1.', 1:m) ,
paste0('PC2.', 1:m) ,
paste0('PC3.', 1:m) ,
paste0('PC1.Espacial', 1:m) ,
paste0('PC2.Espacial', 1:m) ,
paste0('PC3.Espacial', 1:m) )
m <- 4
c(paste0('RGB.Laplaciano', 1:m),
paste0('RGB.Sobelx', 1:m) ,
paste0('RGB.Sobely', 1:m) ,
paste0('RGB.Canny', 1:m) ,
paste0('R', 1:m) ,
paste0('G', 1:m) ,
paste0('B', 1:m) ,
paste0('R.Espacial', 1:m) ,
paste0('G.Espacial', 1:m) ,
paste0('B.Espacial', 1:m) ,
paste0('HSV.Laplaciano', 1:m),
paste0('HSV.Sobelx', 1:m) ,
paste0('HSV.Sobely', 1:m) ,
paste0('HSV.Canny', 1:m) ,
paste0('H', 1:m) ,
paste0('S', 1:m) ,
paste0('V', 1:m),
paste0('H.Espacial', 1:m) ,
paste0('S.Espacial', 1:m),
paste0('V.Espacial', 1:m),
paste0('Eigen', 1:3) ,
paste0('BGR.Laplaciano', 1:m),
paste0('BGR.Sobelx', 1:m) ,
paste0('BGR.Sobely', 1:m) ,
paste0('BGR.Canny', 1:m) ,
paste0('PC1.', 1:m) ,
paste0('PC2.', 1:m) ,
paste0('PC3.', 1:m) ,
paste0('PC1.Espacial', 1:m) ,
paste0('PC2.Espacial', 1:m) ,
paste0('PC3.Espacial', 1:m) )
Sys.Date()
año <- as.integer(substr(Sys.Date(), 1, 4))
año
x <- 0:2
alarm()
cat(date(), "\n", "FELIZ AÑO NUEVO 2019", "\n")
plot(x, x, type = "n", ann = F, axes = F)
text(1, 1, "FELIZ AÑO NUEVO 2019", cex = 2.5)
repeat{
año <- as.integer(substr(Sys.Date(), 1, 4))
x <- 0:2
if (año == 2019L){
alarm()
cat(date(), "\n", "FELIZ AÑO NUEVO 2019", "\n")
plot(x, x, type = "n", ann = F, axes = F)
text(1, 1, "FELIZ AÑO NUEVO 2019", cex = 2.5)
break
}
else {
plot(x, x, type = "n", ann = F, axes = F)
text(1, 1, date(), cex = 2.5)
Sys.sleep(1)
}
#install.packages('XML')
library(XML)
path <- "C:\\Users\\fou-f\\Desktop\\SPI2019\\Parser\\PosiblementeCorrectos\\"
PosiblementeCorrectos <- dir()
#install.packages('XML')
library(XML)
path <- "C:\\Users\\fou-f\\Desktop\\SPI2019\\Parser\\PosiblementeCorrectos\\"
PosiblementeCorrectos <- dir()
PosiblementeCorrectos
load("C:/Users/fou-f/Desktop/SPI2019/app/entrada.rdata")
shiny::runApp('Desktop/SPI2019/app')
runApp('Desktop/SPI2019/app')
entrada[1, 'tTipoAparato']
class(entrada[1, 'tTipoAparato'])
runApp('Desktop/SPI2019/app')
entrada$tTipoAparato
runApp('Desktop/SPI2019/app')
?ovserve
?observe
runApp('Desktop/SPI2019/app')
?reactiveValues
runApp('Desktop/SPI2019/app')
setwd("C:\\Users\\fou-f\\Desktop\\SPI2019\\app\\")
dir()
###############################################
# Datos #######################################
datos <- read.csv("ELCHIDO.csv") # requerimos que el dataframe se llame data
entrada <- datos[1,]
names(entrada)
save(entrada, file ='entrada.rdata')
################################################
################## Modelos ###################
arbol <- function(variable.predecir, data=datos)
{
# Closure para crear MUCHOS MODELOS
# nombre.variable (string): Nombre de la variable que se va a sugerir
# data (dataframe): Data frame con el historico
# REGRESA UN MODELO ENTRENADO
library(rpart)
# generamos la formula para el modelo
formula.foo <- as.formula(paste0(variable.predecir, "~ ."))
rpart(formula.foo, data=data ) # 5 arboles peque FALTA MAXIMO NUMERO DE OPCIONES
}
# CREACION DE N MODELOS ########################
inicio <- Sys.time()
library(parallel)
MODELOS <- mclapply(names(datos), function(x) arbol( variable.predecir=x), mc.cores = 1)
fin <- Sys.time()
fin-inicio
names(MODELOS) <- names(datos)
names(MODELOS)
names(datos)
save(MODELOS, file='MODELOS.rdata')
MODELOS[['iNumFases']]
runApp()
load('MODELOS.rdata')
MODELOS[['tTipoAparato']]
MODELOS[['iNumFases']]
load('entrada.rdata')
predict(MODELOS[['tTipoAparato']],entrada )
class(MODELOS[['tTipoAparato']])
?predict.rpart
predict(MODELOS[['tTipoAparato']],entrada, type='vector' )
predict(MODELOS[['tTipoAparato']],entrada, type='class' )
runApp()
?switch (object,
case = action
)
runApp()
?switch (object,
case = action
)
runApp()
load('entrada.rdata')
entrada$iNumFases
runApp()
?observeEvent
runApp()
?radioButtons
runApp()
?verbatimTextOutput
runApp()
?selectInput
runApp()
setwd("C:\\Users\\fou-f\\Desktop\\SPI2019\\app\\")
dir()
###############################################
# Datos #######################################
datos <- read.csv("ELCHIDO.csv") # requerimos que el dataframe se llame data
str(datos)
names(datos)[1:20]
datos$tTipoAparato
datos$tTipoAparato <- as.character(datos$tTipoAparato)
datos$tTipoAparato
datos$iNumFases
datos$iNumFases <- as.character(datos$iNumFases)
datos$iFrecuencia
datos$iFrecuencia <- as.character(datos$iFrecuencia)
datos$tTipoArreglo
datos$tTipoArreglo <- as.character(datos$tTipoArreglo)
datos$tTipoOptimizador
datos$tTipoOptimizador <- as.character(datos$tTipoOptimizador)
datos$dRelTransformacion
datos$dRelTransformacion <- as.character(datos$dRelTransformacion)
datos$bLlevaTerciario
datos$bLlevaTerciario <- as.character(datos$bLlevaTerciario)
datos$IDevCercano <- as.character(datos$IDevCercano)
datos$IVoltDefPor
datos$IVoltDefPor <- as.character(datos$IVoltDefPor)
datos$IVoltDefPor
datos$DVoltSistGen <- as.character(datos$DVoltSistGen)
datos$DVoltSistGen
datos$dVoltajeSistAT
datos$dVoltajeSistATInterfaz
datos$dVoltajePrefallaRL
datos$dVoltajePrefallaRL <- as.character(datos$dVoltajePrefallaRL)
datos$dVoltajePrefallaRL
datos$bTerciarioExt
datos$bTerciarioExt <- as.character(datos$bTerciarioExt)
datos$bTerciarioCargado
datos$bTerciarioCargado <- as.character(datos$bTerciarioCargado)
datos$tNormaGar
datos$tNormaGar <- as.character(datos$tNormaGar)
datos$iLlevaSerie
datos$iLlevaSerie <- as.character(datos$iLlevaSerie)
datos$MSNM
datos$MSNM <- as.character(datos$MSNM)
datos$dZry
datos$dZry <- as.character(datos$dZry)
datos$dZsh
datos$dZsh <- as.character(datos$dZsh)
datos2 <- datos[, 1:20]
sapply(datos2, class)
entrada <- datos2[1, ]
save(entrada, file ='entrada.rdata')
write.csv(datos2, file='ELCHIDOCORTO.csv')
write.csv(datos2, file='ELCHIDOCORTO.csv', row.names = FALSE)
View(datos2)
################################################
################## Modelos ###################
arbol <- function(variable.predecir, data=datos2)
{
# Closure para crear MUCHOS MODELOS
# nombre.variable (string): Nombre de la variable que se va a sugerir
# data (dataframe): Data frame con el historico
# REGRESA UN MODELO ENTRENADO
library(rpart)
# generamos la formula para el modelo
formula.foo <- as.formula(paste0(variable.predecir, "~ ."))
rpart(formula.foo, data=data ) # 5 arboles peque FALTA MAXIMO NUMERO DE OPCIONES
}
# CREACION DE N MODELOS ########################
inicio <- Sys.time()
library(parallel)
MODELOS <- mclapply(names(datos2), function(x) arbol( variable.predecir=x), mc.cores = 1)
View(datos2)
str(datos2)
View(datos2)
setwd("C:\\Users\\fou-f\\Desktop\\SPI2019\\app\\")
dir()
###############################################
# Datos #######################################
datos <- read.csv("ELCHIDO.csv") # requerimos que el dataframe se llame data
datos$tTipoAparato
datos$tTipoAparato <- as.character(datos$tTipoAparato)
datos$iNumFases
datos$iNumFases <- as.character(datos$iNumFases)
datos$iFrecuencia
datos$tTipoArreglo
datos$tTipoArreglo <- as.character(datos$tTipoArreglo)
datos$tTipoOptimizador
datos$tTipoOptimizador <- as.character(datos$tTipoOptimizador)
datos$dRelTransformacion
datos$dRelTransformacion <- as.character(datos$dRelTransformacion)
datos$bLlevaTerciario
datos$bLlevaTerciario <- as.character(datos$bLlevaTerciario)
datos$IDevCercano
datos$IDevCercano <- as.character(datos$IDevCercano)
datos$IVoltDefPor
datos$DVoltSistGen
datos$dVoltajePrefallaRL
datos$dVoltajePrefallaRL <- as.character(datos$dVoltajePrefallaRL)
datos$bTerciarioExt
datos$bTerciarioExt <- as.character(datos$bTerciarioExt)
datos$bTerciarioCargado
datos$bTerciarioCargado <- as.character(datos$bTerciarioCargado)
datos$tNormaGar
datos$tNormaGar <- as.character(datos$tNormaGar)
datos$iLlevaSerie
datos$MSNM
#datos$iLlevaSerie <- as.character(datos$iLlevaSerie)
datos$MSNM <- as.character(datos$MSNM)
datos$dZry
datos$dZsh
#datos$dZry <- as.character(datos$dZry)
#datos$dZsh <- as.character(datos$dZsh)
datos2 <- datos[, c(1,2,4:8,21:26,28)]
sapply(datos2, class)
#datos$dZry <- as.character(datos$dZry)
#datos$dZsh <- as.character(datos$dZsh)
datos2 <- datos[, c(1,2,4:8,11:16,18)]
sapply(datos2, class)
datos$MSNM
#datos$dZry <- as.character(datos$dZry)
#datos$dZsh <- as.character(datos$dZsh)
datos2 <- datos[, c(1,2,4:8,11:16,18)]
sapply(datos2, class)
entrada <- datos2[1, ]
save(entrada, file ='entrada.rdata')
write.csv(datos2, file='ELCHIDOCORTO.csv', row.names = FALSE)
################################################
################## Modelos ###################
arbol <- function(variable.predecir, data=datos2)
{
# Closure para crear MUCHOS MODELOS
# nombre.variable (string): Nombre de la variable que se va a sugerir
# data (dataframe): Data frame con el historico
# REGRESA UN MODELO ENTRENADO
library(rpart)
# generamos la formula para el modelo
formula.foo <- as.formula(paste0(variable.predecir, "~ ."))
rpart(formula.foo, data=data ) # 5 arboles peque FALTA MAXIMO NUMERO DE OPCIONES
}
# CREACION DE N MODELOS ########################
inicio <- Sys.time()
library(parallel)
MODELOS <- mclapply(names(datos2), function(x) arbol( variable.predecir=x), mc.cores = 1)
fin <- Sys.time()
fin-inicio
names(MODELOS) <- names(datos2)
names(datos2)
save(MODELOS, file='MODELOS.rdata')
MODELOS[['iNumFases']]
runApp()
load('entrada.rdata')
View(entrada)
runApp()
load('MODELOS.rdata')
View(entrada)
MODELOS[['iNumFases']]
entrada
predict(MODELOS[['iNumFases']],entrada, type='vector' )
?predict.rpart
runApp()
predict(MODELOS[['tTipoAparato']],entrada, type='class' )
entrada$tTipoAparato
runApp()
setwd("C:\\Users\\fou-f\\Desktop\\SPI2019\\app\\")
dir()
###############################################
# Datos #######################################
datos <- read.csv("ELCHIDO.csv") # requerimos que el dataframe se llame data
datos$tTipoAparato <- as.character(datos$tTipoAparato)
datos$iNumFases <- as.character(datos$iNumFases)
3#datos$iFrecuencia <- as.character(datos$iFrecuencia)
datos$tTipoArreglo <- as.character(datos$tTipoArreglo)
datos$tTipoOptimizador <- as.character(datos$tTipoOptimizador)
datos$dRelTransformacion <- as.character(datos$dRelTransformacion)
datos$bLlevaTerciario <- as.character(datos$bLlevaTerciario)
datos$IDevCercano <- as.character(datos$IDevCercano)
#datos$IVoltDefPor <- as.character(datos$IVoltDefPor)
#datos$DVoltSistGen <- as.character(datos$DVoltSistGen)
datos$dVoltajeSistAT
datos$dVoltajeSistATInterfaz
datos$dVoltajePrefallaRL <- as.character(datos$dVoltajePrefallaRL)
datos$bTerciarioExt <- as.character(datos$bTerciarioExt)
datos$bTerciarioCargado <- as.character(datos$bTerciarioCargado)
datos$tNormaGar <- as.character(datos$tNormaGar)
#datos$iLlevaSerie <- as.character(datos$iLlevaSerie)
datos$MSNM <- as.character(datos$MSNM)
#datos$dZry <- as.character(datos$dZry)
#datos$dZsh <- as.character(datos$dZsh)
datos2 <- datos[, c(1,2,4:8,11:16,18)]
#################
unique(datos2$tTipoArreglo)
#################
sort(unique(datos2$tTipoArreglo))
runApp()
View(datos2)
runApp()
datos2$tTipoArreglo
runApp()
?sliderInput
runApp()
all.equal(rep(0,2), c(0,0))
runApp()
datos2$MSNM
unique(datos2$MSNM)
sort(unique(datos2$MSNM))
runApp()
