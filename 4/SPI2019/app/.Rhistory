runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny/dwd')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
?boxcox
?box
?plotlyOutput
runApp('~/Desktop/Ecobici/Shiny')
?box
runApp('~/Desktop/Ecobici/Shiny')
?dashboardHeader
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
setwd("/home/fou/Desktop/Ecobici/DataSubset/")
library(readr)
library(lubridate)
library(hms)
load( file='tablaFiltro.Rdata')
library(ggplot2)
library(plotly)
names(tabla2)
tabla2%>% select(Genero_Usuario, Edad_Usuario ) %>% group_by(Genero_Usuario, Edad_Usuario) %>%
summarise(Porcentaje =n()) -> x
x %>% group_by(Genero_Usuario)%>% summarise(Porcentaje=sum(Porcentaje)) -> x
x$Porcentaje <- x$Porcentaje/sum(x$Porcentaje)
names(x) <- c('Genero', 'Porcentaje')
class(x) <- 'data.frame'
p <- ggplot(x, aes(x=Genero, y=Porcentaje, fill=Genero)) + geom_bar(stat = 'identity')  +
scale_fill_manual(values=c('#604B89', 'orange')) + theme_minimal() +xlab('') +ylab('') +
ggtitle('Distribución del generó')
p <- ggplotly(p)
tabla2 %>% group_by(Fecha_Retiro) %>% summarise(viajes=n()) -> viajes.salida
p
library(dplyr)
setwd("/home/fou/Desktop/Ecobici/DataSubset/")
library(readr)
library(lubridate)
library(dplyr)
library(hms)
load( file='tablaFiltro.Rdata')
library(ggplot2)
library(plotly)
names(tabla2)
tabla2%>% select(Genero_Usuario, Edad_Usuario ) %>% group_by(Genero_Usuario, Edad_Usuario) %>%
summarise(Porcentaje =n()) -> x
x %>% group_by(Genero_Usuario)%>% summarise(Porcentaje=sum(Porcentaje)) -> x
x$Porcentaje <- x$Porcentaje/sum(x$Porcentaje)
names(x) <- c('Genero', 'Porcentaje')
class(x) <- 'data.frame'
p <- ggplot(x, aes(x=Genero, y=Porcentaje, fill=Genero)) + geom_bar(stat = 'identity')  +
scale_fill_manual(values=c('#604B89', 'orange')) + theme_minimal() +xlab('') +ylab('') +
ggtitle('Distribución del generó')
p
p <- ggplotly(p)
tabla2 %>% group_by(Fecha_Retiro) %>% summarise(viajes=n()) -> viajes.salida
p
#############################################
names(viajes.salida)
sapply(viajes.salida, class)
p <- ggplot(viajes.salida, aes(x=dmy(Fecha_Retiro), y=viajes)) + geom_line(colour='#604B89') +
xlim(c(ymd('2017-01-01'), ymd('2018-10-31'))) + theme_minimal() + xlab('Fecha') + ylab('Viajes por día') +
ggtitle('Viajes en ECOBICI')
p
ggplotly(p)
save(p, file='DelimitacionTiempo.Rdata')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
load('DelimitacionTiempo.Rdata')
load('DelimitacionTiempo.Rdata')
setwd("~/Desktop/Ecobici/DataSubset")
load('DelimitacionTiempo.Rdata')
setwd("~/Desktop/Ecobici/Shiny")
load('DelimitacionTiempo.Rdata')
DelimitacionTiempo <- p
save(DelimitacionTiempo, 'DelimitacionTiempo.Rdata')
save(DelimitacionTiempo, file ='DelimitacionTiempo.Rdata')
load('DelimitacionTiempo.Rdata')
load('DelimitacionTiempo.Rdata')
runApp()
setwd("/home/fou/Desktop/Ecobici/DataSubset/")
library(readr)
library(lubridate)
library(dplyr)
library(hms)
load( file='tablaFiltro.Rdata')
library(ggplot2)
library(plotly)
names(tabla2)
tabla2%>% select(Genero_Usuario, Edad_Usuario ) %>% group_by(Genero_Usuario, Edad_Usuario) %>%
summarise(Porcentaje =n()) -> x
x %>% group_by(Genero_Usuario)%>% summarise(Porcentaje=sum(Porcentaje)) -> x
x$Porcentaje <- x$Porcentaje/sum(x$Porcentaje)
names(x) <- c('Genero', 'Porcentaje')
class(x) <- 'data.frame'
p <- ggplot(x, aes(x=Genero, y=Porcentaje, fill=Genero)) + geom_bar(stat = 'identity')  +
scale_fill_manual(values=c('#604B89', 'orange')) + theme_minimal() +xlab('') +ylab('') +
ggtitle('Distribución del generó')
p <- ggplotly(p)
tabla2 %>% group_by(Fecha_Retiro) %>% summarise(viajes=n()) -> viajes.salida
p
genero <- p
save(genero, file='genero.Rdata')
#############################################
names(viajes.salida)
sapply(viajes.salida, class)
p <- ggplot(viajes.salida, aes(x=dmy(Fecha_Retiro), y=viajes)) + geom_line(colour='#604B89') +
xlim(c(ymd('2017-01-01'), ymd('2018-10-31'))) + theme_minimal() + xlab('Fecha') + ylab('Viajes por día') +
ggtitle('Viajes en ECOBICI')
p
ggplotly(p)
hora <- p
###############################
# En que horarios hay mayor afluencia ?
##############################
tabla2 %>% select(Hora_Retiro) %>%  group_by(Hora_Retiro) %>% summarise(viajes=n()) -> horarios
horarios$Hora_Retiro <- as.hms(horarios$Hora_Retiro)
p <- ggplot(horarios, aes(x=Hora_Retiro , y=viajes)) + geom_line(colour='#604B89') +
theme_minimal() + xlab('Horario') + ylab('Viajes') +
ggtitle('Viajes en ECOBICI, por segundo')
p <- ggplotly(p)
p
hora <- p
save(hora, file='genero.Rdata')
load( file='tablaFiltro.Rdata')
library(ggplot2)
library(plotly)
names(tabla2)
tabla2%>% select(Genero_Usuario, Edad_Usuario ) %>% group_by(Genero_Usuario, Edad_Usuario) %>%
summarise(Porcentaje =n()) -> x
x %>% group_by(Genero_Usuario)%>% summarise(Porcentaje=sum(Porcentaje)) -> x
x$Porcentaje <- x$Porcentaje/sum(x$Porcentaje)
names(x) <- c('Genero', 'Porcentaje')
class(x) <- 'data.frame'
p <- ggplot(x, aes(x=Genero, y=Porcentaje, fill=Genero)) + geom_bar(stat = 'identity')  +
scale_fill_manual(values=c('#604B89', 'orange')) + theme_minimal() +xlab('') +ylab('') +
ggtitle('Distribución del generó')
p <- ggplotly(p)
tabla2 %>% group_by(Fecha_Retiro) %>% summarise(viajes=n()) -> viajes.salida
p
genero <- p
save(genero, file='genero.Rdata')
#############################################
names(viajes.salida)
sapply(viajes.salida, class)
p <- ggplot(viajes.salida, aes(x=dmy(Fecha_Retiro), y=viajes)) + geom_line(colour='#604B89') +
xlim(c(ymd('2017-01-01'), ymd('2018-10-31'))) + theme_minimal() + xlab('Fecha') + ylab('Viajes por día') +
ggtitle('Viajes en ECOBICI')
p
ggplotly(p)
hora <- p
###############################
# En que horarios hay mayor afluencia ?
##############################
tabla2 %>% select(Hora_Retiro) %>%  group_by(Hora_Retiro) %>% summarise(viajes=n()) -> horarios
horarios$Hora_Retiro <- as.hms(horarios$Hora_Retiro)
p <- ggplot(horarios, aes(x=Hora_Retiro , y=viajes)) + geom_line(colour='#604B89') +
theme_minimal() + xlab('Horario') + ylab('Viajes') +
ggtitle('Viajes en ECOBICI, por segundo')
p <- ggplotly(p)
p
hora <- p
save(hora, file='hora.Rdata')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
load('genero.Rdata')
load('hora.Rdata')
setwd("~/Desktop/Ecobici/Shiny")
load('genero.Rdata')
load('hora.Rdata')
runApp()
shiny::runApp()
setwd("C:\\Users\\fou-f\\Desktop\\MCE2\\4\\SPI2019\\app")
setwd('/home/fou/Desktop/MCE2/4/SPI2019/app')
dir()
administrativas <- c(1,2,3,8,9)
categoricas <- c(4, 5, 6, 11, 12, 18, 19, 20, 21, 28, 29, 30, 31, 35, 55,
57, 63, 64, 65, 66, 67, 69, 70, 71, 72, 73, 74, 75, 76, 77,
88, 89, 90, 100, 101, 111, 112, 114, 117, 130, 132, 133, 134,
135, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 170)
embarque <- 29:34
numericas <- c(13, 15, 17, 22, 23, 24, 25, 26, 27, 32, 33, 34, 36, 37, 38, 45,
46, 47, 48, 49, 50, 58, 59, 60, 68, 78, 79, 80, 81, 82, 83, 84, 85,
86, 87, 91, 93, 94, 97, 98, 102, 106, 107, 126, 127, 128, 129)
# definicion de funciones para rellenar el transformador base de la simulacion
calcula.moda <- function(x)
{
# x (character): columna de tipo caracter
# salida: mode de la columna
frecuencias <- table(x)
maxi <- which.max(frecuencias)
moda <- frecuencias[maxi]
return(names(moda))
}
calcula.mediana <- function(x)
{
# x (numeric): columna de tipo numerica
# salida: mediana de la columna
mediana <- median(x)
return( mediana)
}
###############################################
# correcion de tipos de Datos y construccion del transformador base para la simulacion en la app ###########
datos <- read.csv("dataframeVerdesPresentes.csv", stringsAsFactors = FALSE) #
s <- datos
sapply(datos, class)
# cast de numericas a factores 'character' para que las salidas de 'predict' sean caracteres y no niveles
datos[, categoricas] <- lapply(datos[, categoricas], function(x) as.character(x))
datos[, embarque] <- lapply(datos[, embarque], function(x) as.character(x))
# construccion de transformacion base para la app
entrada <- datos[1, ]
entrada[1, categoricas] <- mapply(datos[, categoricas], FUN=calcula.moda)
entrada[1, embarque] <- mapply(datos[, embarque], FUN=calcula.moda)
entrada[1, numericas] <- mapply(datos[, numericas], FUN=calcula.mediana)
datos <- datos[, -embarque]    # eliminamos las variables 'administrativas' por no ser importantes para la prediccion
entrada <- entrada[, -embarque]
save(entrada, file ='entrada.rdata')
# En analisis de sensibilidad mostro que las 5 variables numericas mas importantes son
importantes.numericas <- c('Enfriamiento.i_ElevTempP3', 'Enfriamiento.i_ElevTempP2',
'Tanque.iSegConservador', 'Enfriamiento.i_ElevTempP1',
'Enfriamiento.bLlevaConservador')
importantes.categoricas <- c('Garantias.dCapExcitacion', 'Garantias.dCapEficReg',
'Configurables.bFreeBuckling', 'bLlevaTerciario',
'tNormaGar')
####################################################################
setwd('/home/fou/Desktop/MCE2/4/SPI2019/app')
dir()
administrativas <- c(1,2,3,8,9)
categoricas <- c(4, 5, 6, 11, 12, 18, 19, 20, 21, 28, 29, 30, 31, 35, 55,
57, 63, 64, 65, 66, 67, 69, 70, 71, 72, 73, 74, 75, 76, 77,
88, 89, 90, 100, 101, 111, 112, 114, 117, 130, 132, 133, 134,
135, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 170)
embarque <- 29:34
numericas <- c(13, 15, 17, 22, 23, 24, 25, 26, 27, 32, 33, 34, 36, 37, 38, 45,
46, 47, 48, 49, 50, 58, 59, 60, 68, 78, 79, 80, 81, 82, 83, 84, 85,
86, 87, 91, 93, 94, 97, 98, 102, 106, 107, 126, 127, 128, 129)
# definicion de funciones para rellenar el transformador base de la simulacion
calcula.moda <- function(x)
{
# x (character): columna de tipo caracter
# salida: mode de la columna
frecuencias <- table(x)
maxi <- which.max(frecuencias)
moda <- frecuencias[maxi]
return(names(moda))
}
calcula.mediana <- function(x)
{
# x (numeric): columna de tipo numerica
# salida: mediana de la columna
mediana <- median(x)
return( mediana)
}
###############################################
# correcion de tipos de Datos y construccion del transformador base para la simulacion en la app ###########
datos <- read.csv("dataframeVerdesPresentes.csv", stringsAsFactors = FALSE) #
s <- datos
sapply(datos, class)
# cast de numericas a factores 'character' para que las salidas de 'predict' sean caracteres y no niveles
datos[, categoricas] <- lapply(datos[, categoricas], function(x) as.character(x))
datos[, embarque] <- lapply(datos[, embarque], function(x) as.character(x))
# construccion de transformacion base para la app
entrada <- datos[1, ]
entrada[1, categoricas] <- mapply(datos[, categoricas], FUN=calcula.moda)
entrada[1, embarque] <- mapply(datos[, embarque], FUN=calcula.moda)
entrada[1, numericas] <- mapply(datos[, numericas], FUN=calcula.mediana)
datos <- datos[, -embarque]    # eliminamos las variables 'administrativas' por no ser importantes para la prediccion
#entrada <- entrada[, -embarque]
entrada <- entrada
#entrada <- entrada[, -embarque]
entrada <- entrada[, c(importantes.categoricas, importantes.numericas)]
save(entrada, file ='entrada.rdata')
write.csv(datos, file='VariablesVerdesCorrectas.csv', row.names = FALSE)
# Closure para crear MUCHOS MODELOS
# nombre.variable (string): Nombre de la variable que se va a sugerir
# data (dataframe): Data frame con el historico
# REGRESA UN MODELO ENTRENADO
library(adabag)
?boosting
arbol <- function(variable.predecir, data=datos)
{
# Closure para crear MUCHOS MODELOS
# nombre.variable (string): Nombre de la variable que se va a sugerir
# data (dataframe): Data frame con el historico
# REGRESA UN MODELO ENTRENADO
library(adabag)
# generamos la formula para el modelo
formula.foo <- as.formula(paste0(variable.predecir, "~ ."))
boosting(formula.foo, data=data , mfinal = 50) # 5 arboles peque FALTA MAXIMO NUMERO DE OPCIONES
}
# CREACION DE N MODELOS ########################
sapply(datos[, importantes.categoricas], class)
sapply(datos[, importantes.numericas], class)
inicio <- Sys.time()
library(parallel)
arbol <- function(variable.predecir, data=datos[, c(importantes.categoricas, importantes.numericas)])
{
# Closure para crear MUCHOS MODELOS
# nombre.variable (string): Nombre de la variable que se va a sugerir
# data (dataframe): Data frame con el historico
# REGRESA UN MODELO ENTRENADO
library(adabag)
# generamos la formula para el modelo
formula.foo <- as.formula(paste0(variable.predecir, "~ ."))
boosting(formula.foo, data=data , mfinal = 50) # 5 arboles peque FALTA MAXIMO NUMERO DE OPCIONES
}
# CREACION DE N MODELOS ########################
sapply(datos[, importantes.categoricas], class)
sapply(datos[, importantes.numericas], class)
# En analisis de sensibilidad mostro que las 5 variables numericas mas importantes son
importantes.numericas <- c('Enfriamiento.i_ElevTempP3', 'Enfriamiento.i_ElevTempP2',
'Tanque.iSegConservador', 'Enfriamiento.i_ElevTempP1',
'Enfriamiento.bLlevaConservador')
importantes.categoricas <- c('Garantias.dCapExcitacion', 'Garantias.dCapEficReg',
'Configurables.bFreeBuckling', 'bLlevaTerciario',
'tNormaGar')
####################################################################
setwd('/home/fou/Desktop/MCE2/4/SPI2019/app')
dir()
administrativas <- c(1,2,3,8,9)
categoricas <- c(4, 5, 6, 11, 12, 18, 19, 20, 21, 28, 29, 30, 31, 35, 55,
57, 63, 64, 65, 66, 67, 69, 70, 71, 72, 73, 74, 75, 76, 77,
88, 89, 90, 100, 101, 111, 112, 114, 117, 130, 132, 133, 134,
135, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 170)
embarque <- 29:34
numericas <- c(13, 15, 17, 22, 23, 24, 25, 26, 27, 32, 33, 34, 36, 37, 38, 45,
46, 47, 48, 49, 50, 58, 59, 60, 68, 78, 79, 80, 81, 82, 83, 84, 85,
86, 87, 91, 93, 94, 97, 98, 102, 106, 107, 126, 127, 128, 129)
# definicion de funciones para rellenar el transformador base de la simulacion
calcula.moda <- function(x)
{
# x (character): columna de tipo caracter
# salida: mode de la columna
frecuencias <- table(x)
maxi <- which.max(frecuencias)
moda <- frecuencias[maxi]
return(names(moda))
}
calcula.mediana <- function(x)
{
# x (numeric): columna de tipo numerica
# salida: mediana de la columna
mediana <- median(x)
return( mediana)
}
###############################################
# correcion de tipos de Datos y construccion del transformador base para la simulacion en la app ###########
datos <- read.csv("dataframeVerdesPresentes.csv", stringsAsFactors = FALSE) #
s <- datos
sapply(datos, class)
# cast de numericas a factores 'character' para que las salidas de 'predict' sean caracteres y no niveles
datos[, categoricas] <- lapply(datos[, categoricas], function(x) as.character(x))
datos[, embarque] <- lapply(datos[, embarque], function(x) as.character(x))
# construccion de transformacion base para la app
entrada <- datos[1, ]
entrada[1, categoricas] <- mapply(datos[, categoricas], FUN=calcula.moda)
entrada[1, embarque] <- mapply(datos[, embarque], FUN=calcula.moda)
entrada[1, numericas] <- mapply(datos[, numericas], FUN=calcula.mediana)
datos <- datos[, -embarque]    # eliminamos las variables 'administrativas' por no ser importantes para la prediccion
entrada <- entrada[, -embarque]
entrada <- entrada[, c(importantes.categoricas, importantes.numericas)]
save(entrada, file ='entrada.rdata')
write.csv(datos, file='VariablesVerdesCorrectas.csv', row.names = FALSE)
arbol <- function(variable.predecir, data=datos[, c(importantes.categoricas, importantes.numericas)])
{
# Closure para crear MUCHOS MODELOS
# nombre.variable (string): Nombre de la variable que se va a sugerir
# data (dataframe): Data frame con el historico
# REGRESA UN MODELO ENTRENADO
library(adabag)
# generamos la formula para el modelo
formula.foo <- as.formula(paste0(variable.predecir, "~ ."))
boosting(formula.foo, data=data , mfinal = 50) # 5 arboles peque FALTA MAXIMO NUMERO DE OPCIONES
}
# CREACION DE N MODELOS ########################
sapply(datos[, importantes.categoricas], class)
sapply(datos[, importantes.numericas], class)
# En analisis de sensibilidad mostro que las 5 variables numericas mas importantes son
importantes.numericas <- c('Enfriamiento.i_TORElev4', 'Enfriamiento.i_HSRElev4',
'Enfriamiento.i_TORElev5', 'Enfriamiento.i_HSRElev5',
'dRuido2')
importantes.categoricas <- c('Garantias.dCapExcitacion', 'Garantias.dCapEficReg',
'Garantias.dCapPerd', 'Enfriamiento.i_ElevTempP3',
'iDestino')
####################################################################
setwd('/home/fou/Desktop/MCE2/4/SPI2019/app')
dir()
administrativas <- c(1,2,3,8,9)
categoricas <- c(4, 5, 6, 11, 12, 18, 19, 20, 21, 28, 29, 30, 31, 35, 55,
57, 63, 64, 65, 66, 67, 69, 70, 71, 72, 73, 74, 75, 76, 77,
88, 89, 90, 100, 101, 111, 112, 114, 117, 130, 132, 133, 134,
135, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 170)
embarque <- 29:34
numericas <- c(13, 15, 17, 22, 23, 24, 25, 26, 27, 32, 33, 34, 36, 37, 38, 45,
46, 47, 48, 49, 50, 58, 59, 60, 68, 78, 79, 80, 81, 82, 83, 84, 85,
86, 87, 91, 93, 94, 97, 98, 102, 106, 107, 126, 127, 128, 129)
# definicion de funciones para rellenar el transformador base de la simulacion
calcula.moda <- function(x)
{
# x (character): columna de tipo caracter
# salida: mode de la columna
frecuencias <- table(x)
maxi <- which.max(frecuencias)
moda <- frecuencias[maxi]
return(names(moda))
}
calcula.mediana <- function(x)
{
# x (numeric): columna de tipo numerica
# salida: mediana de la columna
mediana <- median(x)
return( mediana)
}
###############################################
# correcion de tipos de Datos y construccion del transformador base para la simulacion en la app ###########
datos <- read.csv("dataframeVerdesPresentes.csv", stringsAsFactors = FALSE) #
s <- datos
sapply(datos, class)
# cast de numericas a factores 'character' para que las salidas de 'predict' sean caracteres y no niveles
datos[, categoricas] <- lapply(datos[, categoricas], function(x) as.character(x))
datos[, embarque] <- lapply(datos[, embarque], function(x) as.character(x))
# construccion de transformacion base para la app
entrada <- datos[1, ]
entrada[1, categoricas] <- mapply(datos[, categoricas], FUN=calcula.moda)
entrada[1, embarque] <- mapply(datos[, embarque], FUN=calcula.moda)
entrada[1, numericas] <- mapply(datos[, numericas], FUN=calcula.mediana)
datos <- datos[, -embarque]    # eliminamos las variables 'administrativas' por no ser importantes para la prediccion
entrada <- entrada[, -embarque]
entrada <- entrada[, c(importantes.categoricas, importantes.numericas)]
c(importantes.categoricas, importantes.numericas)
# En analisis de sensibilidad mostro que las 5 variables numericas mas importantes son
importantes.numericas <- c('Enfriamiento.i_TORElev4', 'Enfriamiento.i_HSRElev4',
'Enfriamiento.i_TORElev5', 'Enfriamiento.i_HSRElev5',
'dRuido2')
importantes.categoricas <- c('Garantias.dCapExcitacion', 'Garantias.dCapEficReg',
'Garantias.dCapPerd', 'Enfriamiento.i_ElevTempP3',
'iDestino')
####################################################################
setwd('/home/fou/Desktop/MCE2/4/SPI2019/app')
dir()
administrativas <- c(1,2,3,8,9)
categoricas <- c(4, 5, 6, 11, 12, 18, 19, 20, 21, 28, 29, 30, 31, 35, 55,
57, 63, 64, 65, 66, 67, 69, 70, 71, 72, 73, 74, 75, 76, 77,
88, 89, 90, 100, 101, 111, 112, 114, 117, 130, 132, 133, 134,
135, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 170)
embarque <- 29:34
numericas <- c(13, 15, 17, 22, 23, 24, 25, 26, 27, 32, 33, 34, 36, 37, 38, 45,
46, 47, 48, 49, 50, 58, 59, 60, 68, 78, 79, 80, 81, 82, 83, 84, 85,
86, 87, 91, 93, 94, 97, 98, 102, 106, 107, 126, 127, 128, 129)
# definicion de funciones para rellenar el transformador base de la simulacion
calcula.moda <- function(x)
{
# x (character): columna de tipo caracter
# salida: mode de la columna
frecuencias <- table(x)
maxi <- which.max(frecuencias)
moda <- frecuencias[maxi]
return(names(moda))
}
calcula.mediana <- function(x)
{
# x (numeric): columna de tipo numerica
# salida: mediana de la columna
mediana <- median(x)
return( mediana)
}
###############################################
# correcion de tipos de Datos y construccion del transformador base para la simulacion en la app ###########
datos <- read.csv("dataframeVerdesPresentes.csv", stringsAsFactors = FALSE) #
s <- datos
sapply(datos, class)
# cast de numericas a factores 'character' para que las salidas de 'predict' sean caracteres y no niveles
datos[, categoricas] <- lapply(datos[, categoricas], function(x) as.character(x))
datos[, embarque] <- lapply(datos[, embarque], function(x) as.character(x))
# construccion de transformacion base para la app
entrada <- datos[1, ]
entrada[1, categoricas] <- mapply(datos[, categoricas], FUN=calcula.moda)
entrada[1, embarque] <- mapply(datos[, embarque], FUN=calcula.moda)
entrada[1, numericas] <- mapply(datos[, numericas], FUN=calcula.mediana)
datos <- datos[, -administrativas]    # eliminamos las variables 'administrativas' por no ser importantes para la prediccion
entrada <- entrada[, -administrativas]
entrada <- entrada[, c(importantes.categoricas, importantes.numericas)]
save(entrada, file ='entrada.rdata')
write.csv(datos, file='VariablesVerdesCorrectas.csv', row.names = FALSE)
arbol <- function(variable.predecir, data=datos[, c(importantes.categoricas, importantes.numericas)])
{
# Closure para crear MUCHOS MODELOS
# nombre.variable (string): Nombre de la variable que se va a sugerir
# data (dataframe): Data frame con el historico
# REGRESA UN MODELO ENTRENADO
library(adabag)
# generamos la formula para el modelo
formula.foo <- as.formula(paste0(variable.predecir, "~ ."))
boosting(formula.foo, data=data , mfinal = 50) # 5 arboles peque FALTA MAXIMO NUMERO DE OPCIONES
}
# CREACION DE N MODELOS ########################
sapply(datos[, importantes.categoricas], class)
sapply(datos[, importantes.numericas], class)
inicio <- Sys.time()
library(parallel)
?save
inicio <- Sys.time()
library(parallel)
MODELOS <- mclapply(c(importantes.categoricas, importantes.numericas), function(x) arbol( variable.predecir=x), mc.cores = 6)
