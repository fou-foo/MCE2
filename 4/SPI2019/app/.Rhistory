{
#aplicamos el test para cada lag
resultado <- mapply(function(x)
{
formula <- paste(names(datos)[x], collapse = '+')
formula <- as.formula(paste0('y1 ~ ', formula, '-1'))
modelo <- lm(formula , data = datos )
resumen <- summary(modelo)
# nos fijamos si todos los coeficientes de la regresion
# son significativos individualmente
coeficientes.significativos <- resumen$coefficients[, 'Pr(>|t|)']
coeficientes.significativos <- coeficientes.significativos <= 0.05
if(sum(coeficientes.significativos) == 1)
{
big <- BIC(modelo)
# en caso de que todos los coeficientes sean significativos regresamos
# el BIC de la regresion
return(big)
} else {return(Inf)} #si un coeficiente al menos es no significativo
#regresamos un BIC infinito
}, 2:lag)
}
if (option == 'c')
{
datos[, 'c'] <- rep(1, dim(datos)[1] )
#aplicamos el test para cada lag
resultado <- mapply(function(x)
{
formula <- paste(names(datos)[x], collapse = '+')
formula <- as.formula(paste0('y1 ~ ', formula))
modelo <- lm(formula , data = datos )
resumen <- summary(modelo)
# nos fijamos si todos los coeficientes de la regresion
# son significativos individualmente
coeficientes.significativos <- resumen$coefficients[, 'Pr(>|t|)']
coeficientes.significativos <- coeficientes.significativos <= 0.05
if(sum(coeficientes.significativos) == 2)
{
big <- BIC(modelo)
# en caso de que todos los coeficientes sean significativos regresamos
#el BIC de la regresion
return(big)
}else {return(Inf)} #si un coeficiente al menos es no significativo
#regresamos un BIC infinito
}, 2:lag)
}
if (option == 't')
{
datos[, 't'] <- cumsum(1:dim(datos)[1])
#aplicamos el test para cada lag
resultado <- mapply(function(x)
{
formula <- paste(c(names(datos)[x], 't'), collapse = '+')
formula <- as.formula(paste0('y1 ~ ', formula, '-1'))
modelo <- lm(formula , data = datos )
resumen <- summary(modelo)
# nos fijamos si todos los coeficientes de la regresion
# son significativos individualmente
coeficientes.significativos <- resumen$coefficients[, 'Pr(>|t|)']
coeficientes.significativos <- coeficientes.significativos <= 0.05
if(sum(coeficientes.significativos) == 2)
{
big <- BIC(modelo)
# en caso de que todos los coeficientes sean significativos regresamos
#el BIC de la regresion
return(big)
}else { return(Inf)}  #si un coeficiente al menos es no significativo
#regresamos un BIC infinito
}, 2:lag)
}
if (option == 'both')
{
datos[, 't'] <- cumsum(1:dim(datos)[1])
#aplicamos el test para cada lag
resultado <- mapply(function(x)
{
formula <- paste(c(names(datos)[2:(x)], 't'), collapse = '+')
formula <- as.formula(paste0('y1 ~ ', formula))
modelo <- lm(formula , data = datos )
resumen <- summary(modelo)
# nos fijamos si todos los coeficientes de la regresion
# son significativos individualmente
coeficientes.significativos <- resumen$coefficients[, 'Pr(>|t|)']
coeficientes.significativos <- coeficientes.significativos <= 0.05
if(sum(coeficientes.significativos) == 3)
{
big <- BIC(modelo)
# en caso de que todos los coeficientes sean significativos regresamos
#el BIC de la regresion
return(big)
} else { return(Inf)}  #si un coeficiente al menos es no significativo
#regresamos un BIC infinito
}, 2:lag)
}
parsimonia <- which.min(resultado)
names(parsimonia) <- 'Lag optimo'
return(parsimonia)
}
diferencia <- today()- ymd('2008-01-01')
fecha <- as.numeric(diferencia)
today()-days(fecha) #checar fecha de inicio
first.date <- Sys.Date() - fecha #actualización en tiempo real
last.date <- Sys.Date()
freq.data <- 'weekly'  # frecuencia semanal
# lectura de tickerts
Componentes_Investing_com_United_States_500 <- read_csv("Componentes Investing.com United States 500.csv") # previanmente descargamos de
#https://mx.investing.com/indices/investing.com-us-500-components los nombres de las empresas
tickers <- Componentes_Investing_com_United_States_500$Símbolo
companias <- BatchGetSymbols(tickers = tickers,
first.date = first.date,
last.date = last.date,
freq.data = freq.data,
do.complete.data = FALSE, #sihay nulos los descartamos
cache.folder = file.path(tempdir(),'BGS_Cache')) # cache in tempdir()
# comprobamos que variable es la que se registra 'price.close '
#a <- companias$df.tickers
#a <- subset(a, ticker=='A')
#sapply(a,class )
#a <- a[ a$price.open !=a$price.high,  ]
#a <- a[ a$price.low !=a$price.high,  ]
#a <- a[ a$price.low !=a$price.close ,  ]
#a <- a[ a$price.adjusted !=a$price.close ,  ]
#a <- unique(as.data.frame(a)) #identificamos la variable de interes
serie <- companias$df.tickers
class(serie) <- 'data.frame'
serie %>% select(ticker, ref.date, price.close ) -> serie# era open o close ?
SP500 <- BatchGetSymbols(tickers = "^GSPC",
first.date = first.date,
last.date = last.date,
freq.data = freq.data,
do.complete.data = FALSE, #sihay nulos los descartamos
cache.folder = file.path(tempdir(),'BGS_Cache'))
#names(SP500)
SP500 <- as.data.frame(SP500$df.tickers)[, c(2,4)]
sp.500 <- na.omit(SP500)
serie2 <- dcast(serie, ref.date ~ ticker, value.var = 'price.close' )
#write_csv(serie2, path='serie2.csv')
#serie2 <- read_csv( file='serie2.csv')
serie3 <- apply(serie2, 2, function(x) sum(is.na(x))) # identificamos series problematicas
#table(serie3)
malas <- which(serie3 > 8 )
serie4 <- serie2[,  !(colnames(serie2) %in% names(malas)) ]
serie5 <- na.omit(serie4)
class(serie5) <- 'data.frame'
serie5$ref.date <- as.Date(serie5$ref.date)
serie.cruda <- serie5 # para comparacion sin estacionalizar
par(mfrow=c(3,3))
#inspeccion visual
for(i in 1:(dim(serie5)[2]-1))
{
s <- ts(serie5[, i], start = c(2008,1), frequency = 54)
class(s)
if(i %% 20==0) plot(s, main=as.character(names(serie5)[i]), xlab='series brutas')
}
par(mfrow=c(1,1))
# quitamos tendencia
quita.tendencia <- quita.tendencia.init(inicio= c(2008, 1),frecuencia = 12 )
series <- mclapply(FUN=quita.tendencia, serie5[,2:dim(serie5)[2]], mc.cores = 4)
install.packages("Cairo")
install.packages("imager")
install.packages("tiff")
N<-100
M<-200
beta<-1
tamanio_ensemble<-5000
L<-array(0,dim = c(length(MP_parametrizado(N,M,beta)),0))
#install.packages("QZ")
library(beepr)
library(RMTstat)
install.packages("beepr")
#install.packages("QZ")
library(beepr)
library(RMTstat)
library(QZ)
f.densidad <-function(N,M,beta)
{
# Entradas:
# N (numeric): numero de variables
# M (numeric): numero de observaciones
# beta(numeric): indica el ensamble LOE (1), LSE(4) y (2) LUO
if(beta == 1)
{
#Caso LOE
c <- N/M # la razon entre las dimensiones de la matriz
H <- matrix(rnorm(n = N*M,mean = 0,sd = 1),nrow = N,ncol = M ) #construimos la matriz densa
H <- H%*%t(H) # la hacemos simetrica
VP <- eigen(H)$values
}
if(beta == 2)
{
#CASO LUE
c <- N/M
Real <- rnorm(N*M,mean = 0,sd = 1)
Imaginaria <- rnorm(N*M,mean = 0,sd = 1)
H<- matrix(complex(real = Real,imaginary = Imaginaria),nrow = N,ncol = M )
H_t<- t(matrix(complex(real = Real,imaginary = -Imaginaria),nrow = N,ncol = M ))
W <- H%*%(H_t)
VP <- eigen(W)$values
}
if(beta == 4)
{
# caso LSE
library(QZ)
Real <- rnorm(N*M,mean = 0,sd = 1)
Imaginaria <- rnorm(N*M,mean = 0,sd = 1)
A <- matrix(complex(real = Real,imaginary = Imaginaria),nrow = N,ncol = M )
A_c <- matrix(complex(real = Real,imaginary = -Imaginaria),nrow = N,ncol = M )
Real <- rnorm(N*M,mean = 0,sd = 1)
Imaginaria <- rnorm(N*M,mean = 0,sd = 1)
B <- matrix(complex(real = Real,imaginary = Imaginaria),nrow = N,ncol = M )
B_c <- matrix(complex(real = Real,imaginary = -Imaginaria),nrow = N,ncol = M )
aux1 <- cbind(A,B)
aux2 <- cbind(-B_c,A_c)
H <- rbind(aux1,aux2)
W <- H%*%H(H)
VP <- eigen(W)$values
}
return(VP)
}
L<-array(0,dim = c(length(f.densidad(N,M,beta)),0))
nstall.packages("tictoc")
install.packages("tictoc")
for (i in 1:tamanio_ensemble) {
L<-cbind(L,MP_parametrizado(N,M,beta))
print(i)
}
L<-cbind(L,f.densidad(N,M,beta))
N<-100
M<-200
beta<-1
tamanio_ensemble<-5000
L<-array(0,dim = c(length(f.densidad(N,M,beta)),0))
for (i in 1:tamanio_ensemble) {
L<-cbind(L,f.densidad(N,M,beta))
print(i)
}
res<-hist(L,breaks = 100,col = "red",border = "black")
res<-density(L/100,n = 100)
valor<-density(rmp(n = tamanio_ensemble,ndf = 200,pdim = 100),n=100 )
ks.test(res$y, valor$y/2 )
valo
valor
valor$y
ks.test(res$y, valor$y/2 )
plot(res$x,res$y,main="Test K-S")
lines(valor$x*2,valor$y/2,col="blue")
ks.test(L, rmp(n = tamanio_ensemble,ndf = 200,pdim = 100))
ks.test(L/100, rmp(n = tamanio_ensemble,ndf = 200,pdim = 100)/2)
ks.test(L/100, rmp(n = tamanio_ensemble,ndf = 200,pdim = 100)/2, exact = TRUE)
?ks.test
ks.test(L/100, rmp(n = tamanio_ensemble,ndf = 200,pdim = 100)/2, exact = TRUE)
ks.test(L/100, rmp(n = tamanio_ensemble,ndf = 200,pdim = 100)/2, exact = FALSE)
13+15
devtools::install_github('diegovalle/mxmaps')
install.packages("sf")
load("/home/fou/Desktop/Ecobici/DataSubset/.RData")
1270*.2
load('serie_diaria.Rdata')
shiny::runApp('Desktop/Ecobici/Shiny')
runApp('Desktop/Ecobici/Shiny')
load('serie_diaria.Rdata')
setwd("/home/fou/Desktop/Ecobici/Data/")
load('serie_diaria.Rdata')
serie_diaria
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny/dwd')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
?boxcox
?box
?plotlyOutput
runApp('~/Desktop/Ecobici/Shiny')
?box
runApp('~/Desktop/Ecobici/Shiny')
?dashboardHeader
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
setwd("/home/fou/Desktop/Ecobici/DataSubset/")
library(readr)
library(lubridate)
library(hms)
load( file='tablaFiltro.Rdata')
library(ggplot2)
library(plotly)
names(tabla2)
tabla2%>% select(Genero_Usuario, Edad_Usuario ) %>% group_by(Genero_Usuario, Edad_Usuario) %>%
summarise(Porcentaje =n()) -> x
x %>% group_by(Genero_Usuario)%>% summarise(Porcentaje=sum(Porcentaje)) -> x
x$Porcentaje <- x$Porcentaje/sum(x$Porcentaje)
names(x) <- c('Genero', 'Porcentaje')
class(x) <- 'data.frame'
p <- ggplot(x, aes(x=Genero, y=Porcentaje, fill=Genero)) + geom_bar(stat = 'identity')  +
scale_fill_manual(values=c('#604B89', 'orange')) + theme_minimal() +xlab('') +ylab('') +
ggtitle('Distribución del generó')
p <- ggplotly(p)
tabla2 %>% group_by(Fecha_Retiro) %>% summarise(viajes=n()) -> viajes.salida
p
library(dplyr)
setwd("/home/fou/Desktop/Ecobici/DataSubset/")
library(readr)
library(lubridate)
library(dplyr)
library(hms)
load( file='tablaFiltro.Rdata')
library(ggplot2)
library(plotly)
names(tabla2)
tabla2%>% select(Genero_Usuario, Edad_Usuario ) %>% group_by(Genero_Usuario, Edad_Usuario) %>%
summarise(Porcentaje =n()) -> x
x %>% group_by(Genero_Usuario)%>% summarise(Porcentaje=sum(Porcentaje)) -> x
x$Porcentaje <- x$Porcentaje/sum(x$Porcentaje)
names(x) <- c('Genero', 'Porcentaje')
class(x) <- 'data.frame'
p <- ggplot(x, aes(x=Genero, y=Porcentaje, fill=Genero)) + geom_bar(stat = 'identity')  +
scale_fill_manual(values=c('#604B89', 'orange')) + theme_minimal() +xlab('') +ylab('') +
ggtitle('Distribución del generó')
p
p <- ggplotly(p)
tabla2 %>% group_by(Fecha_Retiro) %>% summarise(viajes=n()) -> viajes.salida
p
#############################################
names(viajes.salida)
sapply(viajes.salida, class)
p <- ggplot(viajes.salida, aes(x=dmy(Fecha_Retiro), y=viajes)) + geom_line(colour='#604B89') +
xlim(c(ymd('2017-01-01'), ymd('2018-10-31'))) + theme_minimal() + xlab('Fecha') + ylab('Viajes por día') +
ggtitle('Viajes en ECOBICI')
p
ggplotly(p)
save(p, file='DelimitacionTiempo.Rdata')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
load('DelimitacionTiempo.Rdata')
load('DelimitacionTiempo.Rdata')
setwd("~/Desktop/Ecobici/DataSubset")
load('DelimitacionTiempo.Rdata')
setwd("~/Desktop/Ecobici/Shiny")
load('DelimitacionTiempo.Rdata')
DelimitacionTiempo <- p
save(DelimitacionTiempo, 'DelimitacionTiempo.Rdata')
save(DelimitacionTiempo, file ='DelimitacionTiempo.Rdata')
load('DelimitacionTiempo.Rdata')
load('DelimitacionTiempo.Rdata')
runApp()
setwd("/home/fou/Desktop/Ecobici/DataSubset/")
library(readr)
library(lubridate)
library(dplyr)
library(hms)
load( file='tablaFiltro.Rdata')
library(ggplot2)
library(plotly)
names(tabla2)
tabla2%>% select(Genero_Usuario, Edad_Usuario ) %>% group_by(Genero_Usuario, Edad_Usuario) %>%
summarise(Porcentaje =n()) -> x
x %>% group_by(Genero_Usuario)%>% summarise(Porcentaje=sum(Porcentaje)) -> x
x$Porcentaje <- x$Porcentaje/sum(x$Porcentaje)
names(x) <- c('Genero', 'Porcentaje')
class(x) <- 'data.frame'
p <- ggplot(x, aes(x=Genero, y=Porcentaje, fill=Genero)) + geom_bar(stat = 'identity')  +
scale_fill_manual(values=c('#604B89', 'orange')) + theme_minimal() +xlab('') +ylab('') +
ggtitle('Distribución del generó')
p <- ggplotly(p)
tabla2 %>% group_by(Fecha_Retiro) %>% summarise(viajes=n()) -> viajes.salida
p
genero <- p
save(genero, file='genero.Rdata')
#############################################
names(viajes.salida)
sapply(viajes.salida, class)
p <- ggplot(viajes.salida, aes(x=dmy(Fecha_Retiro), y=viajes)) + geom_line(colour='#604B89') +
xlim(c(ymd('2017-01-01'), ymd('2018-10-31'))) + theme_minimal() + xlab('Fecha') + ylab('Viajes por día') +
ggtitle('Viajes en ECOBICI')
p
ggplotly(p)
hora <- p
###############################
# En que horarios hay mayor afluencia ?
##############################
tabla2 %>% select(Hora_Retiro) %>%  group_by(Hora_Retiro) %>% summarise(viajes=n()) -> horarios
horarios$Hora_Retiro <- as.hms(horarios$Hora_Retiro)
p <- ggplot(horarios, aes(x=Hora_Retiro , y=viajes)) + geom_line(colour='#604B89') +
theme_minimal() + xlab('Horario') + ylab('Viajes') +
ggtitle('Viajes en ECOBICI, por segundo')
p <- ggplotly(p)
p
hora <- p
save(hora, file='genero.Rdata')
load( file='tablaFiltro.Rdata')
library(ggplot2)
library(plotly)
names(tabla2)
tabla2%>% select(Genero_Usuario, Edad_Usuario ) %>% group_by(Genero_Usuario, Edad_Usuario) %>%
summarise(Porcentaje =n()) -> x
x %>% group_by(Genero_Usuario)%>% summarise(Porcentaje=sum(Porcentaje)) -> x
x$Porcentaje <- x$Porcentaje/sum(x$Porcentaje)
names(x) <- c('Genero', 'Porcentaje')
class(x) <- 'data.frame'
p <- ggplot(x, aes(x=Genero, y=Porcentaje, fill=Genero)) + geom_bar(stat = 'identity')  +
scale_fill_manual(values=c('#604B89', 'orange')) + theme_minimal() +xlab('') +ylab('') +
ggtitle('Distribución del generó')
p <- ggplotly(p)
tabla2 %>% group_by(Fecha_Retiro) %>% summarise(viajes=n()) -> viajes.salida
p
genero <- p
save(genero, file='genero.Rdata')
#############################################
names(viajes.salida)
sapply(viajes.salida, class)
p <- ggplot(viajes.salida, aes(x=dmy(Fecha_Retiro), y=viajes)) + geom_line(colour='#604B89') +
xlim(c(ymd('2017-01-01'), ymd('2018-10-31'))) + theme_minimal() + xlab('Fecha') + ylab('Viajes por día') +
ggtitle('Viajes en ECOBICI')
p
ggplotly(p)
hora <- p
###############################
# En que horarios hay mayor afluencia ?
##############################
tabla2 %>% select(Hora_Retiro) %>%  group_by(Hora_Retiro) %>% summarise(viajes=n()) -> horarios
horarios$Hora_Retiro <- as.hms(horarios$Hora_Retiro)
p <- ggplot(horarios, aes(x=Hora_Retiro , y=viajes)) + geom_line(colour='#604B89') +
theme_minimal() + xlab('Horario') + ylab('Viajes') +
ggtitle('Viajes en ECOBICI, por segundo')
p <- ggplotly(p)
p
hora <- p
save(hora, file='hora.Rdata')
runApp('~/Desktop/Ecobici/Shiny')
runApp('~/Desktop/Ecobici/Shiny')
load('genero.Rdata')
load('hora.Rdata')
setwd("~/Desktop/Ecobici/Shiny")
load('genero.Rdata')
load('hora.Rdata')
runApp()
shiny::runApp()
shiny::runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
runApp('Desktop/MCE2/4/SPI2019/app')
setwd("~/Desktop/MCE2/4/SPI2019/app")
datos <- read.csv("dataframeVerdesPresentes.csv", stringsAsFactors = FALSE) #
sort(unique(datos$Garantias.dCapExcitacion))
administrativas <- c(1,2,3,8,9)
categoricas <- c(4, 5, 6, 11, 12, 18, 19, 20, 21, 28, 29, 30, 31, 35, 55,
57, 63, 64, 65, 66, 67, 69, 70, 71, 72, 73, 74, 75, 76, 77,
88, 89, 90, 100, 101, 111, 112, 114, 117, 130, 132, 133, 134,
135, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 170)
embarque <- 29:34
numericas <- c(13, 15, 17, 22, 23, 24, 25, 26, 27, 32, 33, 34, 36, 37, 38, 45,
46, 47, 48, 49, 50, 58, 59, 60, 68, 78, 79, 80, 81, 82, 83, 84, 85,
86, 87, 91, 93, 94, 97, 98, 102, 106, 107, 126, 127, 128, 129)
datos <- read.csv("dataframeVerdesPresentes.csv", stringsAsFactors = FALSE) #
s <- datos
sapply(datos, class)
# cast de numericas a factores 'character' para que las salidas de 'predict' sean caracteres y no niveles
datos[, categoricas] <- lapply(datos[, categoricas], function(x) as.character(x))
datos[, embarque] <- lapply(datos[, embarque], function(x) as.character(x))
# construccion de transformacion base para la app
entrada <- datos[1, ]
entrada[1, categoricas] <- mapply(datos[, categoricas], FUN=calcula.moda)
entrada[1, embarque] <- mapply(datos[, embarque], FUN=calcula.moda)
entrada[1, numericas] <- mapply(datos[, numericas], FUN=calcula.mediana)
datos <- datos[, -administrativas]    # eliminamos las variables 'administrativas' por no ser importantes para la prediccion
entrada <- entrada[, -administrativas]
entrada <- entrada[, c(importantes.categoricas, importantes.numericas)]
importantes.numericas <- c('Enfriamiento.i_TORElev4', 'Enfriamiento.i_HSRElev4',
'Enfriamiento.i_TORElev5', 'Enfriamiento.i_HSRElev5',
'dRuido2')
importantes.categoricas <- c('Garantias.dCapExcitacion', 'Garantias.dCapEficReg',
'Garantias.dCapPerd', 'Enfriamiento.i_ElevTempP3',
'iDestino')
#
datos <- read.csv("dataframeVerdesPresentes.csv", stringsAsFactors = FALSE) #
s <- datos
sapply(datos, class)
# cast de numericas a factores 'character' para que las salidas de 'predict' sean caracteres y no niveles
datos[, categoricas] <- lapply(datos[, categoricas], function(x) as.character(x))
datos[, embarque] <- lapply(datos[, embarque], function(x) as.character(x))
# construccion de transformacion base para la app
entrada <- datos[1, ]
entrada[1, categoricas] <- mapply(datos[, categoricas], FUN=calcula.moda)
entrada[1, embarque] <- mapply(datos[, embarque], FUN=calcula.moda)
entrada[1, numericas] <- mapply(datos[, numericas], FUN=calcula.mediana)
datos <- datos[, -administrativas]    # eliminamos las variables 'administrativas' por no ser importantes para la prediccion
entrada <- entrada[, -administrativas]
entrada <- entrada[, c(importantes.categoricas, importantes.numericas)]
sort(unique(datos$Garantias.dCapExcitacion))
