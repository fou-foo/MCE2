seq(10)
seq(c(10.2)
seq(c(10.2)
seq(c(10,2))
.11*8
.11*.8
.38*.8
.01*0.8
.02*.08
.01*.8
.02*.8
.08*.0
.09*.1
.09*.01
.8+.11
.088+.38
.304-.01+.009
.008-.2-.009
-0.1+0.28+0.2
0.07-0.08
.11*.8
.38*.8
.01*.8
.02*.8
.09*.1
.09*.1
-.8-.11
.088+.38
-.304-.009-0.01
.008-.2-.009
.7*.4
.7*.1
.2*.4
.2*.1
.9*.1
-.1+.28+.2
.07-0.08
.7*.4
.7*.1
.9*.1
-.1+.28+.2
.7-0.08
.07-0.08
.11*.8
.38*.8
.01*.8
.02*.8
-.8+.38
.088-.01-.009
-.304-.02-.009
-1.1*.8
.88-.01-.009
.9/.2
1/.5
2/.5
2*.01
1/.5
.02/.5
2/.5
.01/.5
.4*4.5
1.8*4
1.08*.02
1/.0216
1-.0216
9.2/.9784
.9/.2
2/.5
.01/.5
1/.5
.2/.5
.4*4.5
1.8*4
1.8*.02
1-.036
9.2/.964
.14*.7
knitr::opts_chunk$set(echo = TRUE)
polyroot(c(1, -1.1, -0.42, 0.861, -0.333, 0.008, 0.16))
?polyroot
polyroot( c( 1 , - 1 , 0.21 , -0.025 ) )
x <- polyroot( c( 1 , - 1 , 0.21 , -0.025 ) )
?abs
abs(a)
abs(x)
x <- polyroot(c(1, -1.1, -0.42, 0.861, -0.333, 0.008, 0.16))
x <- polyroot(c(1, -1.1, -0.42, 0.861, -0.333, 0.008, 0.16))
x
abs(x)
remove(list = ls())
# paqueterIas
library(vars)
library(portes)
library(tseries)
set.seed(1234)
# parAmetros
T <- 100
C <- 100
K <- 2
p <- 2
R <- 500
alpha <- 0.05
# simulamos algunos coeficientes
Phi <- runif(K*K*p, -0.5, 0.5)
# coeficientes VAR(2)
Phi  <- array(Phi, dim = c(K, K, p))
est <- c("maxroot", "AIC", "SC", "HQ", "serial", "arch",
paste("Series",1:p, sep = ""))
est
resultados <- matrix(0, R, length(est))
colnames(resultados) <- est
resultados
# simulaciOn
Y <- varima.sim(model=(list(ar = Phi)), n = T + C, k = K,
innov.dist = "Gaussian")
Y
?varima.sim
remove(list = ls())
# paqueterIas
library(vars)
library(portes)
library(tseries)
# parAmetros
T <- 100
C <- 100
K <- 2
p <- 2
R <- 500
alpha <- 0.05
# simulamos algunos coeficientes
Phi <- runif(K*K*p, -0.5, 0.5)
# coeficientes VAR(2)
Phi  <- array(Phi, dim = c(K, K, p))
est <- c("maxroot", "AIC", "SC", "HQ", "serial", "arch",
paste("Series",1:p, sep = ""))
resultados <- matrix(0, R, length(est))
colnames(resultados) <- est
# simulaciOn
Y <- varima.sim(model=(list(ar = Phi)), n = T + C, k = K,
innov.dist = "Gaussian")
# quitamos las primeras series
Y <- Y[-(1:C),]
# rezago
k <- VARselect(Y, type = "none")
k
?VARselect
# rezago
k <- VARselect(Y, type = "none")
resultados[i,c("AIC", "SC", "HQ")] <- k$selection[c("AIC(n)", "SC(n)",
"HQ(n)")]
i<-1
resultados[i,c("AIC", "SC", "HQ")] <- k$selection[c("AIC(n)", "SC(n)",
"HQ(n)")]
# estimaciOn
var1 <- VAR(Y, p = p, type = "none")
var1
max(roots(var1))
roots(var1)
# estacionariedad
resultados[i, "maxroot"] <- max(roots(var1))
# pruebas de residuales
resultados[i,"serial"] <- serial.test(var1)$serial$p.value
?serial.test
# pruebas de residuales
resultados[i,"serial"] <- serial.test(var1)$serial$p.value # prueba de errores correlacionados
?arch.test
arch.test(var1)
arch.test(var1)$arch
arch.test(var1)$arch$p.value
j <-1
paste("Series",j, sep = "")
causality(var1,
cause = paste("Series.",j,
sep = ""))
?causality
c(causality(var1,
cause = paste("Series.",j,
sep = ""))
c(causality(var1,
cause = paste("Series.",j,
sep = ""))$Granger$p.value)
c(causality(var1,
cause = paste("Series.",j,
sep = ""))$Granger$p.value)
causality(var1,
cause = paste("Series.",j,
sep = ""))$Granger
causality(var1,
cause = paste("Series.",j,
sep = ""))
remove(list = ls())
# paqueterIas
library(vars)
library(portes)
library(tseries)
set.seed(1234)
# parAmetros
T <- 100
C <- 100
K <- 2
p <- 2
R <- 500
alpha <- 0.05
# simulamos algunos coeficientes
Phi <- runif(K*K*p, -0.5, 0.5)
# coeficientes VAR(2)
Phi  <- array(Phi, dim = c(K, K, p))
est <- c("maxroot", "AIC", "SC", "HQ", "serial", "arch",
paste("Series",1:p, sep = ""))
resultados <- matrix(0, R, length(est))
colnames(resultados) <- est
for(i in 1 : R){ # print(i)
# simulaciOn
Y <- varima.sim(model=(list(ar = Phi)), n = T + C, k = K,
innov.dist = "Gaussian")
# quitamos las primeras series
Y <- Y[-(1:C),]
# rezago
k <- VARselect(Y, type = "none")
resultados[i,c("AIC", "SC", "HQ")] <- k$selection[c("AIC(n)", "SC(n)",
"HQ(n)")]
# estimaciOn
var1 <- VAR(Y, p = p, type = "none")
# estacionariedad
resultados[i, "maxroot"] <- max(roots(var1))
# pruebas de residuales
resultados[i,"serial"] <- serial.test(var1)$serial$p.value # prueba de errores correlacionados, test de Portmanteau
resultados[i,"arch"] <- arch.test(var1)$arch$p.value # test de Arch
# causalidad
for(j in 1 : p){
resultados[i,paste("Series",j, sep = "")] <- c(causality(var1,
cause = paste("Series.",j,
sep = ""))$Granger$p.value)
}
}
# observamos los resultados
sum(resultados[,"maxroot"] < 1)/R
resultados[, c("AIC", "SC", "HQ")]
resultados[, c("AIC", "SC", "HQ")] == p
colSums(resultados[, c("AIC", "SC", "HQ")] == p)/R
colSums(resultados[, c("AIC", "SC", "HQ")] == p)
colSums(resultados[, c("AIC", "SC", "HQ")] == p)/R
colSums(resultados[,c("serial", "arch")] > alpha)/R
colSums(resultados[,paste("Series",1:p, sep = "")] < alpha)/R
# simulaciOn
Y <- varima.sim(model=(list(ar = Phi)), n = T + C, k = K,
innov.dist = "Gaussian")
# quitamos las primeras series
Y <- Y[-(1:C),]
# rezago
k <- VARselect(Y, type = "none")
resultados[i,c("AIC", "SC", "HQ")] <- k$selection[c("AIC(n)", "SC(n)",
"HQ(n)")]
# estimaciOn
var1 <- VAR(Y, p = p, type = "none")
# estacionariedad
resultados[i, "maxroot"] <- max(roots(var1))
# pruebas de residuales
resultados[i,"serial"] <- serial.test(var1)$serial$p.value # prueba de errores correlacionados, test de Portmanteau
resultados[i,"arch"] <- arch.test(var1)$arch$p.value # test de Arch
j <- p
causality(var1,
cause = paste("Series.",j,
sep = ""))
causality(var1,
cause = paste("Series.",j,
sep = ""))$Granger
remove(list = ls())
# paqueterIas
library(vars)
library(portes)
library(tseries)
set.seed(1234)
# parAmetros
T <- 100
C <- 100
K <- 2
p <- 2
R <- 500
alpha <- 0.05
# simulamos algunos coeficientes
Phi <- runif(K*K*p, -0.5, 0.5)
# coeficientes VAR(2)
Phi  <- array(Phi, dim = c(K, K, p))
est <- c("maxroot", "AIC", "SC", "HQ", "serial", "arch",
paste("Series",1:p, sep = ""))
resultados <- matrix(0, R, length(est))
colnames(resultados) <- est
for(i in 1 : R){ # print(i)
# simulaciOn
Y <- varima.sim(model=(list(ar = Phi)), n = T + C, k = K,
innov.dist = "Gaussian")
# quitamos las primeras series
Y <- Y[-(1:C),]
# rezago
k <- VARselect(Y, type = "none")
resultados[i,c("AIC", "SC", "HQ")] <- k$selection[c("AIC(n)", "SC(n)",
"HQ(n)")]
# estimaciOn
var1 <- VAR(Y, p = p, type = "none")
# estacionariedad
resultados[i, "maxroot"] <- max(roots(var1))
# pruebas de residuales
resultados[i,"serial"] <- serial.test(var1)$serial$p.value # prueba de errores correlacionados, test de Portmanteau
resultados[i,"arch"] <- arch.test(var1)$arch$p.value # test de Arch
# causalidad
for(j in 1 : p){
resultados[i,paste("Series",j, sep = "")] <- c(causality(var1,
cause = paste("Series.",j,
sep = ""))$Granger$p.value)
}
}
# observamos los resultados
sum(resultados[,"maxroot"] < 1)/R
colSums(resultados[, c("AIC", "SC", "HQ")] == p)/R
colSums(resultados[,c("serial", "arch")] > alpha)/R
colSums(resultados[,paste("Series",1:p, sep = "")] < alpha)/R
# @ ejemplo aplicado con la base de datos de CanadA
data(Canada)
# en logarItmos
lcan <- log(Canada)
adf.p <- matrix(0, ncol(lcan), 2)
rownames(adf.p) <- colnames(lcan)
colnames(adf.p) <- c("l", "fd")
adf.p
for(i in 1 : ncol(Canada)){
adf.p[i, "l"] <- adf.test(lcan[,i])$p.value
adf.p[i, "fd"] <- adf.test(diff(lcan[,i]))$p.value
}
adf.p
# las trabajamos en primeras diferencias
dlcan <- diff(lcan)
# las vemos a travEs del tiempo
ts.plot(scale(dlcan), col = c(1:4))
legend("top", colnames(dlcan), col = c(1:4), lty = 1)
# las vemos a travEs del tiempo
ts.plot(scale(dlcan), col = c(1:4))
legend("top", colnames(dlcan), col = c(1:4), lty = 1)
# determinamos el nUmero de razagos Optimos con el criterio AIC por ejemplo
p <- VARselect(dlcan, type = "const")$selection["AIC(n)"]
# estimamos el var
varc <- VAR(dlcan, p = p, type = "const")
# summary
summary(varc)
# pruebas a los residuales
serial <- serial.test(varc)
serial
arch <- arch.test(varc)
serial
arch
# causalidad de Granger
cau <- matrix(0, ncol(dlcan), 1)
colnames(cau) <- "p.value"
rownames(cau) <- colnames(dlcan)
cau
for(i in 1 : ncol(dlcan))
cau[i,] <- causality(varc, colnames(dlcan)[i])$Granger$p.value
cau <- round(cau, 4)
cau
# pronOsticos
fore <- predict(varc, n.ahead = 12)
plot(fore)
# pronOsticos
fore <- predict(varc, n.ahead = 12)
plot(fore)
# pronOsticos
fore <- predict(varc, n.ahead = 12)
plot(fore)
# pronOsticos
fore <- predict(varc, n.ahead = 12)
plot(fore)
cau <- round(cau, 4)
cau
# pronOsticos
fore <- predict(varc, n.ahead = 12)
plot(fore)
# estimamos las funciones de respuesta-impulso
irff <- irf(varc)
# plot
opp <- par(mfrow = c(4, 4))
ncol(dlcan)
ncol(dlcan)
irff
# plot
opp <- par(mfrow = c(4, 4))
for(j in 1 : ncol(dlcan)){
for(i in 1 : ncol(dlcan)){
mea <- irff$irf[[colnames(dlcan)[j]]][,i]
li <- irff$Lower[[colnames(dlcan)[j]]][,i]
ls <- irff$Upper[[colnames(dlcan)[j]]][,i]
mat_irf <- cbind(mea, li, ls)
ts.plot(mat_irf, ylab = "", xlab = "", col = c(4, 2, 2), lty = c(1, 2, 2))
abline(h = 0, lty = 2, col = 3)
title(paste(colnames(dlcan)[j], "->", colnames(dlcan)[i], sep = ""))
}
}
par(opp)
# plot
opp <- par(mfrow = c(4, 4))
for(j in 1 : ncol(dlcan)){
for(i in 1 : ncol(dlcan)){
mea <- irff$irf[[colnames(dlcan)[j]]][,i]
li <- irff$Lower[[colnames(dlcan)[j]]][,i]
ls <- irff$Upper[[colnames(dlcan)[j]]][,i]
mat_irf <- cbind(mea, li, ls)
ts.plot(mat_irf, ylab = "", xlab = "", col = c(4, 2, 2), lty = c(1, 2, 2))
abline(h = 0, lty = 2, col = 3)
title(paste(colnames(dlcan)[j], "->", colnames(dlcan)[i], sep = ""))
}
}
# plot
opp <- par(mfrow = c(4, 4))
for(j in 1 : ncol(dlcan)){
for(i in 1 : ncol(dlcan)){
mea <- irff$irf[[colnames(dlcan)[j]]][,i]
li <- irff$Lower[[colnames(dlcan)[j]]][,i]
ls <- irff$Upper[[colnames(dlcan)[j]]][,i]
mat_irf <- cbind(mea, li, ls)
ts.plot(mat_irf, ylab = "", xlab = "", col = c(4, 2, 2), lty = c(1, 2, 2))
abline(h = 0, lty = 2, col = 3)
title(paste(colnames(dlcan)[j], "->", colnames(dlcan)[i], sep = ""))
}
}
par(opp)
